<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfaster API Documentation: ByKey Operator Variants</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfaster API Documentation
   &#160;<span id="projectnumber">Development Version</span>
   </div>
   <div id="projectbrief">Super fast distributted computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__bykey.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">ByKey Operator Variants</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>A variant of original operators that groups entries by key to be processed. </p>
<p>ByKey operators use user functions that can access multiple entries of the same corresponding key <em>U F(K, vector&lt;void*&gt;, size_t)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>- Key type of the created dataset </td></tr>
    <tr><td class="paramname">T</td><td>- Value type of the source dataset </td></tr>
    <tr><td class="paramname">L</td><td>- Key type of the created dataset </td></tr>
    <tr><td class="paramname">U</td><td>- Value type of the created dataset</td></tr>
    <tr><td class="paramname">funcP</td><td>- A function pointer of a user function <em>U F(K, vector&lt;void*&gt;, size_t)</em> that will be used on each dataset entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new dataset</dd></dl>
<h2></h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga571d54ed407c328526e7c67cd7be991d"><td class="memTemplParams" colspan="2"><a id="ga571d54ed407c328526e7c67cd7be991d"></a>
template&lt;typename To &gt; </td></tr>
<tr class="memitem:ga571d54ed407c328526e7c67cd7be991d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfaster_1_1fdd.html">fdd</a>&lt; To &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::groupedFdd&lt; K &gt;::mapByKey</b> (mapByKeyG3FunctionP&lt; K, To &gt; funcP)</td></tr>
<tr class="separator:ga571d54ed407c328526e7c67cd7be991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e66cd0a1896a9ba95e093ea665e5f9"><td class="memTemplParams" colspan="2"><a id="ga72e66cd0a1896a9ba95e093ea665e5f9"></a>
template&lt;typename L , typename U &gt; </td></tr>
<tr class="memitem:ga72e66cd0a1896a9ba95e093ea665e5f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfaster_1_1indexedFdd.html">indexedFdd</a>&lt; L, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bykey.html#ga72e66cd0a1896a9ba95e093ea665e5f9">faster::indexedFdd&lt; K, T &gt;::mapByKey</a> (ImapByKeyIFunctionP&lt; K, T, L, U &gt; funcP)</td></tr>
<tr class="memdesc:ga72e66cd0a1896a9ba95e093ea665e5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a indexedFdd&lt;L,U&gt; <br /></td></tr>
<tr class="separator:ga72e66cd0a1896a9ba95e093ea665e5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1f7ce69086373cc5b419da1f8213bdd"><td class="memTemplParams" colspan="2"><a id="gac1f7ce69086373cc5b419da1f8213bdd"></a>
template&lt;typename L , typename U &gt; </td></tr>
<tr class="memitem:gac1f7ce69086373cc5b419da1f8213bdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfaster_1_1indexedFdd.html">indexedFdd</a>&lt; L, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bykey.html#gac1f7ce69086373cc5b419da1f8213bdd">faster::indexedFdd&lt; K, T &gt;::mapByKey</a> (IPmapByKeyIFunctionP&lt; K, T, L, U &gt; funcP)</td></tr>
<tr class="memdesc:gac1f7ce69086373cc5b419da1f8213bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a indexedFdd&lt;L,U*&gt; <br /></td></tr>
<tr class="separator:gac1f7ce69086373cc5b419da1f8213bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993ec5033e2f665437f5d8590794fe0b"><td class="memTemplParams" colspan="2"><a id="ga993ec5033e2f665437f5d8590794fe0b"></a>
template&lt;typename L , typename U &gt; </td></tr>
<tr class="memitem:ga993ec5033e2f665437f5d8590794fe0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfaster_1_1fdd.html">fdd</a>&lt; U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bykey.html#ga993ec5033e2f665437f5d8590794fe0b">faster::indexedFdd&lt; K, T &gt;::mapByKey</a> (mapByKeyIFunctionP&lt; K, T, U &gt; funcP)</td></tr>
<tr class="memdesc:ga993ec5033e2f665437f5d8590794fe0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a fdd&lt;U&gt; <br /></td></tr>
<tr class="separator:ga993ec5033e2f665437f5d8590794fe0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558fd453f0a2ba00515359a46690972d"><td class="memTemplParams" colspan="2"><a id="ga558fd453f0a2ba00515359a46690972d"></a>
template&lt;typename L , typename U &gt; </td></tr>
<tr class="memitem:ga558fd453f0a2ba00515359a46690972d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfaster_1_1fdd.html">fdd</a>&lt; U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bykey.html#ga558fd453f0a2ba00515359a46690972d">faster::indexedFdd&lt; K, T &gt;::mapByKey</a> (PmapByKeyIFunctionP&lt; K, T, U &gt; funcP)</td></tr>
<tr class="memdesc:ga558fd453f0a2ba00515359a46690972d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a fdd&lt;U *&gt; <br /></td></tr>
<tr class="separator:ga558fd453f0a2ba00515359a46690972d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga716f0776aa3644853164bd69c0dad488"><td class="memTemplParams" colspan="2"><a id="ga716f0776aa3644853164bd69c0dad488"></a>
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga716f0776aa3644853164bd69c0dad488"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::updateByKeyIFunctionP</b> = void(*)(K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:ga716f0776aa3644853164bd69c0dad488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c46902b3c015a06eafd3ab600192b3"><td class="memTemplParams" colspan="2"><a id="gac4c46902b3c015a06eafd3ab600192b3"></a>
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gac4c46902b3c015a06eafd3ab600192b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::ImapByKeyIFunctionP</b> = std::pair&lt; L, U &gt;(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:gac4c46902b3c015a06eafd3ab600192b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01309afe79f4cd5db4a4a6396a14b84"><td class="memTemplParams" colspan="2"><a id="gad01309afe79f4cd5db4a4a6396a14b84"></a>
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gad01309afe79f4cd5db4a4a6396a14b84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::mapByKeyIFunctionP</b> = U(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:gad01309afe79f4cd5db4a4a6396a14b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c309fabec604ea3b2636d80ef5cd43"><td class="memTemplParams" colspan="2"><a id="gaf4c309fabec604ea3b2636d80ef5cd43"></a>
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gaf4c309fabec604ea3b2636d80ef5cd43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::IPmapByKeyIFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:gaf4c309fabec604ea3b2636d80ef5cd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6049d8a78d2878f00a161a347e3cf31b"><td class="memTemplParams" colspan="2"><a id="ga6049d8a78d2878f00a161a347e3cf31b"></a>
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga6049d8a78d2878f00a161a347e3cf31b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::PmapByKeyIFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:ga6049d8a78d2878f00a161a347e3cf31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9f61ca3499c9d6a724de99cee68331"><td class="memTemplParams" colspan="2"><a id="gabe9f61ca3499c9d6a724de99cee68331"></a>
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:gabe9f61ca3499c9d6a724de99cee68331"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::IreduceByKeyIFunctionP</b> = std::pair&lt; K, T &gt;(*)(const K &amp;keyA, T *a, size_t sizeA, const K &amp;keyB, T *b, size_t sizeB)</td></tr>
<tr class="separator:gabe9f61ca3499c9d6a724de99cee68331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d340fbec0f98c0b36b1bc2e1b8803fb"><td class="memTemplParams" colspan="2"><a id="ga1d340fbec0f98c0b36b1bc2e1b8803fb"></a>
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga1d340fbec0f98c0b36b1bc2e1b8803fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::ImapByKeyIPFunctionP</b> = std::pair&lt; L, U &gt;(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:ga1d340fbec0f98c0b36b1bc2e1b8803fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1551dad642983a26af40b8211575fc"><td class="memTemplParams" colspan="2"><a id="gaee1551dad642983a26af40b8211575fc"></a>
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gaee1551dad642983a26af40b8211575fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::mapByKeyIPFunctionP</b> = U(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:gaee1551dad642983a26af40b8211575fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960580b7165f12812d5575829fd5b2a9"><td class="memTemplParams" colspan="2"><a id="ga960580b7165f12812d5575829fd5b2a9"></a>
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga960580b7165f12812d5575829fd5b2a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::IPmapByKeyIPFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:ga960580b7165f12812d5575829fd5b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac38b3840b9bfd6fc181b0af9883ddcf"><td class="memTemplParams" colspan="2"><a id="gaac38b3840b9bfd6fc181b0af9883ddcf"></a>
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gaac38b3840b9bfd6fc181b0af9883ddcf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::PmapByKeyIPFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:gaac38b3840b9bfd6fc181b0af9883ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9588170de6c93258536baf80bd3102"><td class="memTemplParams" colspan="2"><a id="ga7c9588170de6c93258536baf80bd3102"></a>
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga7c9588170de6c93258536baf80bd3102"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::IPreduceByKeyIPFunctionP</b> = std::tuple&lt; K, T *, size_t &gt;(*)(K keyA, T **a, size_t *dataSizesA, size_t sizeA, K keyB, T **b, size_t *dataSizesB, size_t sizeB)</td></tr>
<tr class="separator:ga7c9588170de6c93258536baf80bd3102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec777a5b58919804e301ce1a5c98adc"><td class="memTemplParams" colspan="2"><a id="ga9ec777a5b58919804e301ce1a5c98adc"></a>
template&lt;typename K &gt; </td></tr>
<tr class="memitem:ga9ec777a5b58919804e301ce1a5c98adc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::updateByKeyG2FunctionP</b> = void(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:ga9ec777a5b58919804e301ce1a5c98adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67daf7bef40755e03e80b4ac5c0e6034"><td class="memTemplParams" colspan="2"><a id="ga67daf7bef40755e03e80b4ac5c0e6034"></a>
template&lt;typename K &gt; </td></tr>
<tr class="memitem:ga67daf7bef40755e03e80b4ac5c0e6034"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::updateByKeyG3FunctionP</b> = void(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:ga67daf7bef40755e03e80b4ac5c0e6034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed5b483dcd18176555f3532a9570d17"><td class="memTemplParams" colspan="2"><a id="ga6ed5b483dcd18176555f3532a9570d17"></a>
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:ga6ed5b483dcd18176555f3532a9570d17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::flatMapByKeyG2FunctionP</b> = std::deque&lt; To &gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:ga6ed5b483dcd18176555f3532a9570d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga247d6c8c992ecdfd9c525478d4fe4bb8"><td class="memTemplParams" colspan="2"><a id="ga247d6c8c992ecdfd9c525478d4fe4bb8"></a>
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:ga247d6c8c992ecdfd9c525478d4fe4bb8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::flatMapByKeyG3FunctionP</b> = std::deque&lt; To &gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:ga247d6c8c992ecdfd9c525478d4fe4bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab6ad08c8d74a2bd3b821944bc13b32a"><td class="memTemplParams" colspan="2"><a id="gaab6ad08c8d74a2bd3b821944bc13b32a"></a>
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:gaab6ad08c8d74a2bd3b821944bc13b32a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::IflatMapByKeyG2FunctionP</b> = std::deque&lt; std::pair&lt; Ko, To &gt;&gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:gaab6ad08c8d74a2bd3b821944bc13b32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9ab0b2a30dceeb9a67985cefcb345f"><td class="memTemplParams" colspan="2"><a id="gade9ab0b2a30dceeb9a67985cefcb345f"></a>
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:gade9ab0b2a30dceeb9a67985cefcb345f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>faster::IflatMapByKeyG3FunctionP</b> = std::deque&lt; std::pair&lt; Ko, To &gt;&gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:gade9ab0b2a30dceeb9a67985cefcb345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Nov 22 2016 18:46:55 for libfaster API Documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
