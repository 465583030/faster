<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfaster API Documentation: faster Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfaster API Documentation
   &#160;<span id="projectnumber">Development Version</span>
   </div>
   <div id="projectbrief">Super fast distributted computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacefaster.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">faster Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>libfaster main namespace </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa8898687bc64536b60a3d5f365060cd6"><td class="memItemLeft" align="right" valign="top"><a id="aa8898687bc64536b60a3d5f365060cd6"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefaster.html#aa8898687bc64536b60a3d5f365060cd6">fddType</a></td></tr>
<tr class="memdesc:aa8898687bc64536b60a3d5f365060cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dataset type. <br /></td></tr>
<tr class="separator:aa8898687bc64536b60a3d5f365060cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64379512d12d41c6e58f176939abfd80"><td class="memItemLeft" align="right" valign="top"><a id="a64379512d12d41c6e58f176939abfd80"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefaster.html#a64379512d12d41c6e58f176939abfd80">fddOpType</a></td></tr>
<tr class="memdesc:a64379512d12d41c6e58f176939abfd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dataset operation type. <br /></td></tr>
<tr class="separator:a64379512d12d41c6e58f176939abfd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c276ad2cf0991b45ce6f4b1652bb06"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gad3c276ad2cf0991b45ce6f4b1652bb06"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapFunctionP</b> = U(*)(T &amp;input)</td></tr>
<tr class="separator:gad3c276ad2cf0991b45ce6f4b1652bb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac789f70264fc817eede4bf92e9c219e0"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gac789f70264fc817eede4bf92e9c219e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapFunctionP</b> = std::pair&lt; L, U &gt;(*)(T &amp;input)</td></tr>
<tr class="separator:gac789f70264fc817eede4bf92e9c219e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d58a9c53227a5924cb8496424f38335"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga1d58a9c53227a5924cb8496424f38335"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PmapFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(T &amp;input)</td></tr>
<tr class="separator:ga1d58a9c53227a5924cb8496424f38335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af32df57a56a326c5607fd164c0b543"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga6af32df57a56a326c5607fd164c0b543"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPmapFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(T &amp;input)</td></tr>
<tr class="separator:ga6af32df57a56a326c5607fd164c0b543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e180c6074105430541baf6577a54a12"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0e180c6074105430541baf6577a54a12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkMapFunctionP</b> = void(*)(U *output, T *input, size_t size)</td></tr>
<tr class="separator:ga0e180c6074105430541baf6577a54a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8823a57c60753e5c5823fc67837befce"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga8823a57c60753e5c5823fc67837befce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkMapFunctionP</b> = void(*)(L *outKey, U *output, T *input, size_t size)</td></tr>
<tr class="separator:ga8823a57c60753e5c5823fc67837befce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48907e6631187c57ab1667cd21ad4b3b"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga48907e6631187c57ab1667cd21ad4b3b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkMapFunctionP</b> = void(*)(U *output, size_t *outputDataSizes, T *input, size_t size)</td></tr>
<tr class="separator:ga48907e6631187c57ab1667cd21ad4b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf64dcb6de6c9249cf6a8e3ad16e2603"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gacf64dcb6de6c9249cf6a8e3ad16e2603"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkMapFunctionP</b> = void(*)(L *outKey, U *output, size_t *outputDataSizes, T *input, size_t size)</td></tr>
<tr class="separator:gacf64dcb6de6c9249cf6a8e3ad16e2603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab541346ef7fac41096b374a5a4b1699d"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab541346ef7fac41096b374a5a4b1699d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flatMapFunctionP</b> = std::deque&lt; U &gt;(*)(T &amp;input)</td></tr>
<tr class="separator:gab541346ef7fac41096b374a5a4b1699d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd17c939d0b28c2aa7709daf2016c4bb"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gafd17c939d0b28c2aa7709daf2016c4bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IflatMapFunctionP</b> = std::deque&lt; std::pair&lt; L, U &gt;&gt;(*)(T &amp;input)</td></tr>
<tr class="separator:gafd17c939d0b28c2aa7709daf2016c4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c1211c120b49437f09a840ad282c042"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0c1211c120b49437f09a840ad282c042"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PflatMapFunctionP</b> = std::deque&lt; std::pair&lt; U, size_t &gt;&gt;(*)(T &amp;input)</td></tr>
<tr class="separator:ga0c1211c120b49437f09a840ad282c042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca59f0e455ed2034a0e81caa04fdea8"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gaaca59f0e455ed2034a0e81caa04fdea8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPflatMapFunctionP</b> = std::deque&lt; std::tuple&lt; L, U, size_t &gt;&gt;(*)(T &amp;input)</td></tr>
<tr class="separator:gaaca59f0e455ed2034a0e81caa04fdea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad4241d8c2d4641d83b750addbd3825"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaaad4241d8c2d4641d83b750addbd3825"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkFlatMapFunctionP</b> = void(*)(U *&amp;output, size_t &amp;outputSize, T *input, size_t size)</td></tr>
<tr class="separator:gaaad4241d8c2d4641d83b750addbd3825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa361fffa5a84ca6cdd1bf23b2521b7c3"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gaa361fffa5a84ca6cdd1bf23b2521b7c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkFlatMapFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t &amp;outputSize, T *input, size_t size)</td></tr>
<tr class="separator:gaa361fffa5a84ca6cdd1bf23b2521b7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga158792e312ed7f99f7802ce5dc18ab95"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga158792e312ed7f99f7802ce5dc18ab95"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkFlatMapFunctionP</b> = void(*)(U *&amp;output, size_t *&amp;outputDataSizes, size_t &amp;outputSize, T *input, size_t size)</td></tr>
<tr class="separator:ga158792e312ed7f99f7802ce5dc18ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga763d69de0e7eb7d1d53ee06b318eb3d1"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga763d69de0e7eb7d1d53ee06b318eb3d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkFlatMapFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t *&amp;outputDataSizes, size_t &amp;outputSize, T *input, size_t size)</td></tr>
<tr class="separator:ga763d69de0e7eb7d1d53ee06b318eb3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga980901f8c07924742f04646b02f77ffb"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga980901f8c07924742f04646b02f77ffb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduceFunctionP</b> = T(*)(T &amp;a, T &amp;b)</td></tr>
<tr class="separator:ga980901f8c07924742f04646b02f77ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0e90e4869b9e67962cc107e2b498b1"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5e0e90e4869b9e67962cc107e2b498b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkReduceFunctionP</b> = T(*)(T *input, size_t size)</td></tr>
<tr class="separator:ga5e0e90e4869b9e67962cc107e2b498b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91327bad9d0ab5cc7f160b238faa847"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac91327bad9d0ab5cc7f160b238faa847"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapPFunctionP</b> = U(*)(T *input, size_t size)</td></tr>
<tr class="separator:gac91327bad9d0ab5cc7f160b238faa847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75e097c003958f4585370be9ecb1426"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gaf75e097c003958f4585370be9ecb1426"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapPFunctionP</b> = std::pair&lt; L, U &gt;(*)(T *input, size_t size)</td></tr>
<tr class="separator:gaf75e097c003958f4585370be9ecb1426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5c8623ed75599bf57090fcb162ffb4"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaac5c8623ed75599bf57090fcb162ffb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PmapPFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(T *input, size_t size)</td></tr>
<tr class="separator:gaac5c8623ed75599bf57090fcb162ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aba2cb14827dcb31270b41cab68aabf"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga8aba2cb14827dcb31270b41cab68aabf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPmapPFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(T *input, size_t size)</td></tr>
<tr class="separator:ga8aba2cb14827dcb31270b41cab68aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8ce10645cf1b07bd1868ef3880780a"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gabc8ce10645cf1b07bd1868ef3880780a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkMapPFunctionP</b> = void(*)(U *output, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:gabc8ce10645cf1b07bd1868ef3880780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f2d9c0ddabb0e8d022865c38746f0b"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga03f2d9c0ddabb0e8d022865c38746f0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkMapPFunctionP</b> = void(*)(L *outKey, U *output, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga03f2d9c0ddabb0e8d022865c38746f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8fa33eafa86ebe6822506817134632"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga5b8fa33eafa86ebe6822506817134632"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkMapPFunctionP</b> = void(*)(U *output, size_t *outputDataSizes, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga5b8fa33eafa86ebe6822506817134632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66f4e8902cdf0b4e47cc949ac0ada43"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gad66f4e8902cdf0b4e47cc949ac0ada43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkMapPFunctionP</b> = void(*)(L *outKey, U *output, size_t *outputDataSizes, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:gad66f4e8902cdf0b4e47cc949ac0ada43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa163266bfe2e37a92417dd1dfd5b8511"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa163266bfe2e37a92417dd1dfd5b8511"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flatMapPFunctionP</b> = std::deque&lt; U &gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:gaa163266bfe2e37a92417dd1dfd5b8511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9369a384375fabb68f700143321a279"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gac9369a384375fabb68f700143321a279"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IflatMapPFunctionP</b> = std::deque&lt; std::pair&lt; L, U &gt;&gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:gac9369a384375fabb68f700143321a279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01bd17b1c19682275b8d4c9e9161efb2"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga01bd17b1c19682275b8d4c9e9161efb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PflatMapPFunctionP</b> = std::deque&lt; std::pair&lt; U, size_t &gt;&gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:ga01bd17b1c19682275b8d4c9e9161efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59087aff273c806dcc315092b51e925"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gac59087aff273c806dcc315092b51e925"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPflatMapPFunctionP</b> = std::deque&lt; std::tuple&lt; L, U, size_t &gt;&gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:gac59087aff273c806dcc315092b51e925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8832d2db609a90552cbfa51e1b5082d"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac8832d2db609a90552cbfa51e1b5082d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkFlatMapPFunctionP</b> = void(*)(U *&amp;output, size_t &amp;outputSize, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:gac8832d2db609a90552cbfa51e1b5082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c8b1cc00a5f9d694e5cae4260482f8"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gaf3c8b1cc00a5f9d694e5cae4260482f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkFlatMapPFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t &amp;outputSize, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:gaf3c8b1cc00a5f9d694e5cae4260482f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a618e5c22a45158c1073b6094b6a45"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga84a618e5c22a45158c1073b6094b6a45"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkFlatMapPFunctionP</b> = void(*)(U *&amp;output, size_t *outputDataSizes, size_t &amp;outputSize, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga84a618e5c22a45158c1073b6094b6a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75874d292891edb3cab2cb2ad103052d"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga75874d292891edb3cab2cb2ad103052d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkFlatMapPFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t *outputDataSizes, size_t &amp;outputSize, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga75874d292891edb3cab2cb2ad103052d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ed0e204205b394ce44b6a38db3be4c"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57ed0e204205b394ce44b6a38db3be4c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PreducePFunctionP</b> = std::pair&lt; T *, size_t &gt;(*)(T *a, size_t sizeA, T *b, size_t sizeB)</td></tr>
<tr class="separator:ga57ed0e204205b394ce44b6a38db3be4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9603d643cde38851c656e1c8eac1ff13"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9603d643cde38851c656e1c8eac1ff13"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkReducePFunctionP</b> = std::pair&lt; T *, size_t &gt;(*)(T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga9603d643cde38851c656e1c8eac1ff13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeede5f3628246388e6a6026f8d49dbb"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:gaeeede5f3628246388e6a6026f8d49dbb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>updateIFunctionP</b> = void(*)(K &amp;inKey, T &amp;input)</td></tr>
<tr class="separator:gaeeede5f3628246388e6a6026f8d49dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga716f0776aa3644853164bd69c0dad488"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga716f0776aa3644853164bd69c0dad488"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>updateByKeyIFunctionP</b> = void(*)(K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:ga716f0776aa3644853164bd69c0dad488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332d70e5410a8d5ec5e29782293a7e24"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga332d70e5410a8d5ec5e29782293a7e24"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapIFunctionP</b> = std::pair&lt; L, U &gt;(*)(const K &amp;inKey, T &amp;input)</td></tr>
<tr class="separator:ga332d70e5410a8d5ec5e29782293a7e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba7639b6285747affc4573ce803452e"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0ba7639b6285747affc4573ce803452e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapIFunctionP</b> = U(*)(const K &amp;inKey, T &amp;input)</td></tr>
<tr class="separator:ga0ba7639b6285747affc4573ce803452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987b98044fcc70c32c56e9b79ab218c6"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga987b98044fcc70c32c56e9b79ab218c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPmapIFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(const K &amp;inKey, T &amp;input)</td></tr>
<tr class="separator:ga987b98044fcc70c32c56e9b79ab218c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d1b7d89ba8b9e7218ddf700c05ffd5"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga68d1b7d89ba8b9e7218ddf700c05ffd5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PmapIFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(const K &amp;inKey, T &amp;input)</td></tr>
<tr class="separator:ga68d1b7d89ba8b9e7218ddf700c05ffd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c46902b3c015a06eafd3ab600192b3"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gac4c46902b3c015a06eafd3ab600192b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapByKeyIFunctionP</b> = std::pair&lt; L, U &gt;(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:gac4c46902b3c015a06eafd3ab600192b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01309afe79f4cd5db4a4a6396a14b84"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gad01309afe79f4cd5db4a4a6396a14b84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapByKeyIFunctionP</b> = U(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:gad01309afe79f4cd5db4a4a6396a14b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c309fabec604ea3b2636d80ef5cd43"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gaf4c309fabec604ea3b2636d80ef5cd43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPmapByKeyIFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:gaf4c309fabec604ea3b2636d80ef5cd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6049d8a78d2878f00a161a347e3cf31b"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga6049d8a78d2878f00a161a347e3cf31b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PmapByKeyIFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; T * &gt; &amp;input)</td></tr>
<tr class="separator:ga6049d8a78d2878f00a161a347e3cf31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8458ad6a6480ecc969156ab94bd92b"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gaee8458ad6a6480ecc969156ab94bd92b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkMapIFunctionP</b> = void(*)(L *outKey, U *output, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:gaee8458ad6a6480ecc969156ab94bd92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea8660619f575727d3070009fdb0734"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga6ea8660619f575727d3070009fdb0734"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkMapIFunctionP</b> = void(*)(U *output, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:ga6ea8660619f575727d3070009fdb0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6f7cc5f58e322a6d8b685013d9e633"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gadb6f7cc5f58e322a6d8b685013d9e633"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkMapIFunctionP</b> = void(*)(L *outKey, U *output, size_t *outputDataSizes, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:gadb6f7cc5f58e322a6d8b685013d9e633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf05760143da7722dcb9b53de169c8c1"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gabf05760143da7722dcb9b53de169c8c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkMapIFunctionP</b> = void(*)(U *output, size_t *outputDataSizes, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:gabf05760143da7722dcb9b53de169c8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30b9cc4ae1f5d6a0c5f6708042b3f98b"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga30b9cc4ae1f5d6a0c5f6708042b3f98b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IflatMapIFunctionP</b> = std::deque&lt; std::pair&lt; L, U &gt;&gt;(*)(K inKey, T &amp;input)</td></tr>
<tr class="separator:ga30b9cc4ae1f5d6a0c5f6708042b3f98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad79a7f81b549f96bab233b359eda7122"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gad79a7f81b549f96bab233b359eda7122"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flatMapIFunctionP</b> = std::deque&lt; U &gt;(*)(K inKey, T &amp;input)</td></tr>
<tr class="separator:gad79a7f81b549f96bab233b359eda7122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e3f77595065602818d628e6a257912"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga60e3f77595065602818d628e6a257912"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPflatMapIFunctionP</b> = std::deque&lt; std::tuple&lt; L, U, size_t &gt;&gt;(*)(K inKey, T &amp;input)</td></tr>
<tr class="separator:ga60e3f77595065602818d628e6a257912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653f2a3168e9e683478e01f649b87dbb"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga653f2a3168e9e683478e01f649b87dbb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PflatMapIFunctionP</b> = std::deque&lt; std::pair&lt; U, size_t &gt;&gt;(*)(K inKey, T &amp;input)</td></tr>
<tr class="separator:ga653f2a3168e9e683478e01f649b87dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95de08f0fefbf150f266b2405ab2c52a"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga95de08f0fefbf150f266b2405ab2c52a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkFlatMapIFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t &amp;outputSize, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:ga95de08f0fefbf150f266b2405ab2c52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa846e95ac3857cbb64497f73c56950f5"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa846e95ac3857cbb64497f73c56950f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkFlatMapIFunctionP</b> = void(*)(U *&amp;output, size_t &amp;outputSize, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:gaa846e95ac3857cbb64497f73c56950f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647dc45bd371fdc3046f08c286cc956b"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga647dc45bd371fdc3046f08c286cc956b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkFlatMapIFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t *&amp;outputDataSizes, size_t &amp;outputSize, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:ga647dc45bd371fdc3046f08c286cc956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b0805a2bbc284c47d3a80873bea9723"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga6b0805a2bbc284c47d3a80873bea9723"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkFlatMapIFunctionP</b> = void(*)(U *&amp;output, size_t *&amp;outputDataSizes, size_t &amp;outputSize, K *inKey, T *input, size_t size)</td></tr>
<tr class="separator:ga6b0805a2bbc284c47d3a80873bea9723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f80a65dc948bb1e75662fc1e1810d5"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga50f80a65dc948bb1e75662fc1e1810d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IreduceIFunctionP</b> = std::pair&lt; K, T &gt;(*)(const K &amp;keyA, T &amp;a, const K &amp;keyB, T &amp;b)</td></tr>
<tr class="separator:ga50f80a65dc948bb1e75662fc1e1810d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9f61ca3499c9d6a724de99cee68331"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:gabe9f61ca3499c9d6a724de99cee68331"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IreduceByKeyIFunctionP</b> = std::pair&lt; K, T &gt;(*)(const K &amp;keyA, T *a, size_t sizeA, const K &amp;keyB, T *b, size_t sizeB)</td></tr>
<tr class="separator:gabe9f61ca3499c9d6a724de99cee68331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef9dee3732827aaa9a53c81f4188d1b"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga0ef9dee3732827aaa9a53c81f4188d1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkReduceIFunctionP</b> = std::pair&lt; K, T &gt;(*)(K *key, T *input, size_t size)</td></tr>
<tr class="separator:ga0ef9dee3732827aaa9a53c81f4188d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7e1117f4f21bd34ef951cba51c4e26"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga5f7e1117f4f21bd34ef951cba51c4e26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapIPFunctionP</b> = std::pair&lt; L, U &gt;(*)(K inKey, T *input, size_t size)</td></tr>
<tr class="separator:ga5f7e1117f4f21bd34ef951cba51c4e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac819b92c4990bc7879b38d3e85dc3e62"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gac819b92c4990bc7879b38d3e85dc3e62"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapIPFunctionP</b> = U(*)(K inKey, T *input, size_t size)</td></tr>
<tr class="separator:gac819b92c4990bc7879b38d3e85dc3e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924d39688b5355e31efcd5bd76555351"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga924d39688b5355e31efcd5bd76555351"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPmapIPFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(K inKey, T *input, size_t size)</td></tr>
<tr class="separator:ga924d39688b5355e31efcd5bd76555351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6096faff99f26d3dc4597282bb35c89f"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga6096faff99f26d3dc4597282bb35c89f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PmapIPFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(K inKey, T *input, size_t size)</td></tr>
<tr class="separator:ga6096faff99f26d3dc4597282bb35c89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d340fbec0f98c0b36b1bc2e1b8803fb"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga1d340fbec0f98c0b36b1bc2e1b8803fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapByKeyIPFunctionP</b> = std::pair&lt; L, U &gt;(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:ga1d340fbec0f98c0b36b1bc2e1b8803fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1551dad642983a26af40b8211575fc"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gaee1551dad642983a26af40b8211575fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapByKeyIPFunctionP</b> = U(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:gaee1551dad642983a26af40b8211575fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960580b7165f12812d5575829fd5b2a9"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga960580b7165f12812d5575829fd5b2a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPmapByKeyIPFunctionP</b> = std::tuple&lt; L, U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:ga960580b7165f12812d5575829fd5b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac38b3840b9bfd6fc181b0af9883ddcf"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gaac38b3840b9bfd6fc181b0af9883ddcf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PmapByKeyIPFunctionP</b> = std::pair&lt; U, size_t &gt;(*)(const K &amp;inKey, std::vector&lt; std::pair&lt; T *, size_t &gt;&gt;)</td></tr>
<tr class="separator:gaac38b3840b9bfd6fc181b0af9883ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447ec30ee877a388f8c7403a38952410"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga447ec30ee877a388f8c7403a38952410"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkMapIPFunctionP</b> = void(*)(L *outKey, U *output, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga447ec30ee877a388f8c7403a38952410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970040ba860fa32170cb42baf0e4799e"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga970040ba860fa32170cb42baf0e4799e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkMapIPFunctionP</b> = void(*)(U *output, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga970040ba860fa32170cb42baf0e4799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8180a9b7d03c0fd3ed9047a7baa0d444"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga8180a9b7d03c0fd3ed9047a7baa0d444"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkMapIPFunctionP</b> = void(*)(L *outKey, U *output, size_t *outputDataSizes, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga8180a9b7d03c0fd3ed9047a7baa0d444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e4f6294cdac2a40b9ea934afd24fb9"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga08e4f6294cdac2a40b9ea934afd24fb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkMapIPFunctionP</b> = void(*)(U *output, size_t *outputDataSizes, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga08e4f6294cdac2a40b9ea934afd24fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb84f3d27ffaf86addb7a4a28361308c"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gadb84f3d27ffaf86addb7a4a28361308c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IflatMapIPFunctionP</b> = std::deque&lt; std::pair&lt; L, U &gt;&gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:gadb84f3d27ffaf86addb7a4a28361308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8be14aec14e63089848ff35d39a4fcb3"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga8be14aec14e63089848ff35d39a4fcb3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flatMapIPFunctionP</b> = std::deque&lt; U &gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:ga8be14aec14e63089848ff35d39a4fcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7149a73ec5a64ae993c2b94fd6d2655f"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga7149a73ec5a64ae993c2b94fd6d2655f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPflatMapIPFunctionP</b> = std::deque&lt; std::tuple&lt; L, U, size_t &gt;&gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:ga7149a73ec5a64ae993c2b94fd6d2655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7087e8794b547ec3f8a6e20b84a830"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga5f7087e8794b547ec3f8a6e20b84a830"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PflatMapIPFunctionP</b> = std::deque&lt; std::pair&lt; U, size_t &gt;&gt;(*)(T *&amp;input, size_t size)</td></tr>
<tr class="separator:ga5f7087e8794b547ec3f8a6e20b84a830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60edb026f84b2b9e7d1b0aca513f9f4"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:gab60edb026f84b2b9e7d1b0aca513f9f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkFlatMapIPFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t &amp;outputSize, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:gab60edb026f84b2b9e7d1b0aca513f9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962c9de7711b1a49cb10f97eab741899"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:ga962c9de7711b1a49cb10f97eab741899"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkFlatMapIPFunctionP</b> = void(*)(U *&amp;output, size_t &amp;outputSize, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga962c9de7711b1a49cb10f97eab741899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7aa8d709aaac014b6e871861ff57f9"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ga7b7aa8d709aaac014b6e871861ff57f9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkFlatMapIPFunctionP</b> = void(*)(L *&amp;outKey, U *&amp;output, size_t *outputDataSizes, size_t &amp;outputSize, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga7b7aa8d709aaac014b6e871861ff57f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f95fdc0f493e360f63060945416e14"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T , typename U &gt; </td></tr>
<tr class="memitem:gab0f95fdc0f493e360f63060945416e14"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PbulkFlatMapIPFunctionP</b> = void(*)(U *&amp;output, size_t *outputDataSizes, size_t &amp;outputSize, K *inKey, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:gab0f95fdc0f493e360f63060945416e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0621ccc9bcd5359cfc2dc460dfc4351"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:gaf0621ccc9bcd5359cfc2dc460dfc4351"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPreduceIPFunctionP</b> = std::tuple&lt; K, T *, size_t &gt;(*)(K keyA, T *a, size_t sizeA, K keyB, T *b, size_t sizeB)</td></tr>
<tr class="separator:gaf0621ccc9bcd5359cfc2dc460dfc4351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9588170de6c93258536baf80bd3102"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga7c9588170de6c93258536baf80bd3102"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPreduceByKeyIPFunctionP</b> = std::tuple&lt; K, T *, size_t &gt;(*)(K keyA, T **a, size_t *dataSizesA, size_t sizeA, K keyB, T **b, size_t *dataSizesB, size_t sizeB)</td></tr>
<tr class="separator:ga7c9588170de6c93258536baf80bd3102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80929daf5ea00aef1fcb81cd8aee74c1"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga80929daf5ea00aef1fcb81cd8aee74c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IPbulkReduceIPFunctionP</b> = std::tuple&lt; K, T *, size_t &gt;(*)(K *key, T **input, size_t *inputDataSizes, size_t size)</td></tr>
<tr class="separator:ga80929daf5ea00aef1fcb81cd8aee74c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec777a5b58919804e301ce1a5c98adc"><td class="memTemplParams" colspan="2">
template&lt;typename K &gt; </td></tr>
<tr class="memitem:ga9ec777a5b58919804e301ce1a5c98adc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>updateByKeyG2FunctionP</b> = void(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:ga9ec777a5b58919804e301ce1a5c98adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67daf7bef40755e03e80b4ac5c0e6034"><td class="memTemplParams" colspan="2">
template&lt;typename K &gt; </td></tr>
<tr class="memitem:ga67daf7bef40755e03e80b4ac5c0e6034"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>updateByKeyG3FunctionP</b> = void(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:ga67daf7bef40755e03e80b4ac5c0e6034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga682408c556f96213a7ca446407c510da"><td class="memTemplParams" colspan="2">
template&lt;typename K &gt; </td></tr>
<tr class="memitem:ga682408c556f96213a7ca446407c510da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkUpdateG2FunctionP</b> = void(*)(K *keyA, void *a, size_t na, K *keyB, void *b, size_t nb)</td></tr>
<tr class="separator:ga682408c556f96213a7ca446407c510da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1550d5f0229f90a47d1264587fd6dc9"><td class="memTemplParams" colspan="2">
template&lt;typename K &gt; </td></tr>
<tr class="memitem:gab1550d5f0229f90a47d1264587fd6dc9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkUpdateG3FunctionP</b> = void(*)(K *keyA, void *a, size_t na, K *keyB, void *b, size_t nb, K *keyC, void *c, size_t nc)</td></tr>
<tr class="separator:gab1550d5f0229f90a47d1264587fd6dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509cd598ec7468382878c53b0dc1324a"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:ga509cd598ec7468382878c53b0dc1324a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapByKeyG2FunctionP</b> = To(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:ga509cd598ec7468382878c53b0dc1324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b108dc8e2e7b776a6242449f506fcf0"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:ga3b108dc8e2e7b776a6242449f506fcf0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mapByKeyG3FunctionP</b> = To(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:ga3b108dc8e2e7b776a6242449f506fcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7a388c8fbc8135045bd655c1b2dfac"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:gaff7a388c8fbc8135045bd655c1b2dfac"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapByKeyG2FunctionP</b> = std::pair&lt; Ko, To &gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:gaff7a388c8fbc8135045bd655c1b2dfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad646bdfb2c0a86f02cb17edb07e34552"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:gad646bdfb2c0a86f02cb17edb07e34552"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ImapByKeyG3FunctionP</b> = std::pair&lt; Ko, To &gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:gad646bdfb2c0a86f02cb17edb07e34552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed5b483dcd18176555f3532a9570d17"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:ga6ed5b483dcd18176555f3532a9570d17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flatMapByKeyG2FunctionP</b> = std::deque&lt; To &gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:ga6ed5b483dcd18176555f3532a9570d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga247d6c8c992ecdfd9c525478d4fe4bb8"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:ga247d6c8c992ecdfd9c525478d4fe4bb8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flatMapByKeyG3FunctionP</b> = std::deque&lt; To &gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:ga247d6c8c992ecdfd9c525478d4fe4bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab6ad08c8d74a2bd3b821944bc13b32a"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:gaab6ad08c8d74a2bd3b821944bc13b32a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IflatMapByKeyG2FunctionP</b> = std::deque&lt; std::pair&lt; Ko, To &gt;&gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b)</td></tr>
<tr class="separator:gaab6ad08c8d74a2bd3b821944bc13b32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9ab0b2a30dceeb9a67985cefcb345f"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:gade9ab0b2a30dceeb9a67985cefcb345f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IflatMapByKeyG3FunctionP</b> = std::deque&lt; std::pair&lt; Ko, To &gt;&gt;(*)(const K &amp;key, std::vector&lt; void * &gt; &amp;a, std::vector&lt; void * &gt; &amp;b, std::vector&lt; void * &gt; &amp;c)</td></tr>
<tr class="separator:gade9ab0b2a30dceeb9a67985cefcb345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3cf5ee2922729ad44884888aee70ed"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:gaff3cf5ee2922729ad44884888aee70ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkFlatMapG2FunctionP</b> = std::deque&lt; To &gt;(*)(K *keyA, void *a, size_t na, K *keyB, void *b, size_t nb)</td></tr>
<tr class="separator:gaff3cf5ee2922729ad44884888aee70ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94bbbac99a9dbc8c809b7adab93a16c"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename To &gt; </td></tr>
<tr class="memitem:gad94bbbac99a9dbc8c809b7adab93a16c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bulkFlatMapG3FunctionP</b> = std::deque&lt; To &gt;(*)(K *keyA, void *a, size_t na, K *keyB, void *b, size_t nb, K *keyC, void *c, size_t nc)</td></tr>
<tr class="separator:gad94bbbac99a9dbc8c809b7adab93a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e002d973b8a83a0f17d105fa04b279"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:gaa0e002d973b8a83a0f17d105fa04b279"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkFlatMapG2FunctionP</b> = std::deque&lt; std::pair&lt; Ko, To &gt;&gt;(*)(K *keyA, void *a, size_t na, K *keyB, void *b, size_t nb)</td></tr>
<tr class="separator:gaa0e002d973b8a83a0f17d105fa04b279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30be1380be69d2fe9b0a508ff350f60a"><td class="memTemplParams" colspan="2">
template&lt;typename K , typename Ko , typename To &gt; </td></tr>
<tr class="memitem:ga30be1380be69d2fe9b0a508ff350f60a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IbulkFlatMapG3FunctionP</b> = std::deque&lt; std::pair&lt; Ko, To &gt;&gt;(*)(K *keyA, void *a, size_t na, K *keyB, void *b, size_t nb, K *keyC, void *c, size_t nc)</td></tr>
<tr class="separator:ga30be1380be69d2fe9b0a508ff350f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partition function definitions</div></td></tr>
<tr class="memitem:a5a364e0e0a44ae1008621c848032e2e5"><td class="memTemplParams" colspan="2"><a id="a5a364e0e0a44ae1008621c848032e2e5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a364e0e0a44ae1008621c848032e2e5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>onlineFullPartFuncP</b> = int(*)(T &amp;input)</td></tr>
<tr class="separator:a5a364e0e0a44ae1008621c848032e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b23c8b46e5a2d545c778cb82c67d7a0"><td class="memTemplParams" colspan="2"><a id="a1b23c8b46e5a2d545c778cb82c67d7a0"></a>
template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:a1b23c8b46e5a2d545c778cb82c67d7a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IonlineFullPartFuncP</b> = int(*)(K &amp;key, T &amp;input)</td></tr>
<tr class="separator:a1b23c8b46e5a2d545c778cb82c67d7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a31a27bc97724724c1a0454eb750abb4d"><td class="memItemLeft" align="right" valign="top"><a id="a31a27bc97724724c1a0454eb750abb4d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>dFuncName</b> : char { <br />
&#160;&#160;<b>NewWorkerDL</b> = 0x01, 
<b>NewWorkerSDL</b> = 0x02, 
<b>DiscardWorkerDL</b> = 0x03, 
<b>GetTypeDL</b> = 0x04, 
<br />
&#160;&#160;<b>GetKeyTypeDL</b> = 0x05, 
<b>SetDataDL</b> = 0x06, 
<b>SetDataRawDL</b> = 0x07, 
<b>GetLineSizesDL</b> = 0x08, 
<br />
&#160;&#160;<b>GetFddItemDL</b> = 0x09, 
<b>GetKeysDL</b> = 0x0a, 
<b>GetDataDL</b> = 0x0b, 
<b>GetSizeDL</b> = 0x0c, 
<br />
&#160;&#160;<b>ItemSizeDL</b> = 0x0d, 
<b>BaseSizeDL</b> = 0x0e, 
<b>SetSizeDL</b> = 0x0f, 
<b>DeleteItemDL</b> = 0x10, 
<br />
&#160;&#160;<b>ShrinkDL</b> = 0x11, 
<b>InsertDL</b> = 0x12, 
<b>InsertListDL</b> = 0x13, 
<b>PreapplyDL</b> = 0x14, 
<br />
&#160;&#160;<b>CollectDL</b> = 0x15, 
<b>GroupByKeyDL</b> = 0x16, 
<b>CountByKeyDL</b> = 0x17, 
<b>ExchangeDataByKeyDL</b> = 0x18, 
<br />
&#160;&#160;<b>GetKeyLocationDL</b> = 0x19, 
<b>GetUKeysDL</b> = 0x1a, 
<b>SetUKeysDL</b> = 0x1b, 
<b>GetKeyMapDL</b> = 0x1c, 
<br />
&#160;&#160;<b>SetKeyMapDL</b> = 0x1d, 
<b>WriteToFileDL</b> = 0x1e
<br />
 }</td></tr>
<tr class="separator:a31a27bc97724724c1a0454eb750abb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4194fd6017e45751652f28dfa366e1"><td class="memItemLeft" align="right" valign="top"><a id="a4b4194fd6017e45751652f28dfa366e1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>commMode</b> { <b>Local</b>, 
<b>Mesos</b>
 }</td></tr>
<tr class="separator:a4b4194fd6017e45751652f28dfa366e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e3eb4b5b7cff3a3be7a47c3c99ba24"><td class="memItemLeft" align="right" valign="top"><a id="a80e3eb4b5b7cff3a3be7a47c3c99ba24"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>msgTag</b> : int { <br />
&#160;&#160;<b>MSG_TASK</b>, 
<b>MSG_CREATEFDD</b>, 
<b>MSG_CREATEIFDD</b>, 
<b>MSG_CREATEGFDD</b>, 
<br />
&#160;&#160;<b>MSG_DISCARDFDD</b>, 
<b>MSG_FDDSETDATAID</b>, 
<b>MSG_FDDSETDATA</b>, 
<b>MSG_FDDSET2DDATAID</b>, 
<br />
&#160;&#160;<b>MSG_FDDSET2DDATASIZES</b>, 
<b>MSG_FDDSET2DDATA</b>, 
<b>MSG_READFDDFILE</b>, 
<b>MSG_WRITEFDDFILE</b>, 
<br />
&#160;&#160;<b>MSG_FILENAME</b>, 
<b>MSG_COLLECT</b>, 
<b>MSG_FDDDATAID</b>, 
<b>MSG_FDDDATA</b>, 
<br />
&#160;&#160;<b>MSG_TASKRESULT</b>, 
<b>MSG_FDDINFO</b>, 
<b>MSG_FDDSETIDATAID</b>, 
<b>MSG_FDDSETIDATA</b>, 
<br />
&#160;&#160;<b>MSG_FDDSETIKEYS</b>, 
<b>MSG_FDDSET2DIDATAID</b>, 
<b>MSG_FDDSET2DIDATASIZES</b>, 
<b>MSG_FDDSET2DIDATA</b>, 
<br />
&#160;&#160;<b>MSG_FDDSET2DIKEYS</b>, 
<b>MSG_KEYOWNERSHIPSUGEST</b>, 
<b>MSG_MYKEYOWNERSHIP</b>, 
<b>MSG_MYKEYCOUNT</b>, 
<br />
&#160;&#160;<b>MSG_IFDDDATAID</b>, 
<b>MSG_IFDDDATAKEYS</b>, 
<b>MSG_IFDDDATA</b>, 
<b>MSG_COLLECTDATA</b>, 
<br />
&#160;&#160;<b>MSG_KEYMAP</b>, 
<b>MSG_DISTKEYMAP</b>, 
<b>MSG_GROUPBYKEYDATA</b>, 
<b>MSG_FINISH</b>
<br />
 }</td></tr>
<tr class="separator:a80e3eb4b5b7cff3a3be7a47c3c99ba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cf8a7763aa9597e5eec114d9eac616"><td class="memItemLeft" align="right" valign="top"><a id="ad3cf8a7763aa9597e5eec114d9eac616"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>fileMode</b> : int { <b>R</b> = O_RDONLY, 
<b>W</b> = O_WRONLY, 
<b>CR</b> = O_RDONLY | O_CREAT, 
<b>CW</b> = O_WRONLY | O_CREAT
 }</td></tr>
<tr class="separator:ad3cf8a7763aa9597e5eec114d9eac616"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33bcbec3d87aa28bcfa2296d54c7d071"><td class="memItemLeft" align="right" valign="top"><a id="a33bcbec3d87aa28bcfa2296d54c7d071"></a>
<a class="el" href="classfaster_1_1procstat.html">procstat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getProcStat</b> ()</td></tr>
<tr class="separator:a33bcbec3d87aa28bcfa2296d54c7d071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8e6e9b6bc85a2a5b2c1015b9e95b51"><td class="memItemLeft" align="right" valign="top"><a id="a9a8e6e9b6bc85a2a5b2c1015b9e95b51"></a>
<a class="el" href="namespacefaster.html#aa8898687bc64536b60a3d5f365060cd6">fddType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>decodeType</b> (size_t typeCode)</td></tr>
<tr class="separator:a9a8e6e9b6bc85a2a5b2c1015b9e95b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4253cffb9970289129e957cdfb284b"><td class="memItemLeft" align="right" valign="top"><a id="adb4253cffb9970289129e957cdfb284b"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>decodeOptype</b> (<a class="el" href="namespacefaster.html#a64379512d12d41c6e58f176939abfd80">fddOpType</a> op)</td></tr>
<tr class="separator:adb4253cffb9970289129e957cdfb284b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f0f480890cca9363986112d8c1d44e"><td class="memItemLeft" align="right" valign="top"><a id="a64f0f480890cca9363986112d8c1d44e"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>decodeOptypeAb</b> (<a class="el" href="namespacefaster.html#a64379512d12d41c6e58f176939abfd80">fddOpType</a> op)</td></tr>
<tr class="separator:a64f0f480890cca9363986112d8c1d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d8d4c91e8d0cf335085f6db61bdf8"><td class="memTemplParams" colspan="2"><a id="a567d8d4c91e8d0cf335085f6db61bdf8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a567d8d4c91e8d0cf335085f6db61bdf8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (std::vector&lt; T &gt; v)</td></tr>
<tr class="separator:a567d8d4c91e8d0cf335085f6db61bdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad226894887da9a4c32d023b1cd5bf5fc"><td class="memTemplParams" colspan="2"><a id="ad226894887da9a4c32d023b1cd5bf5fc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad226894887da9a4c32d023b1cd5bf5fc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (std::vector&lt; T &gt; v)</td></tr>
<tr class="separator:ad226894887da9a4c32d023b1cd5bf5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0759ec0dc0f77b6dc7f33c626ba09b58"><td class="memTemplParams" colspan="2"><a id="a0759ec0dc0f77b6dc7f33c626ba09b58"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0759ec0dc0f77b6dc7f33c626ba09b58"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum</b> (std::vector&lt; T &gt; v)</td></tr>
<tr class="separator:a0759ec0dc0f77b6dc7f33c626ba09b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c6f3bc8b33d68bcf7c86f876a78e9"><td class="memTemplParams" colspan="2"><a id="ada9c6f3bc8b33d68bcf7c86f876a78e9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada9c6f3bc8b33d68bcf7c86f876a78e9"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stdDev</b> (std::vector&lt; T &gt; v, double mean)</td></tr>
<tr class="separator:ada9c6f3bc8b33d68bcf7c86f876a78e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01426e27eaa86293b11fd2f1f3a2c4c"><td class="memItemLeft" align="right" valign="top"><a id="ab01426e27eaa86293b11fd2f1f3a2c4c"></a>
<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>newWorkerSDL</b> (unsigned long int id, <a class="el" href="namespacefaster.html#aa8898687bc64536b60a3d5f365060cd6">fddType</a> type, size_t size)</td></tr>
<tr class="separator:ab01426e27eaa86293b11fd2f1f3a2c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1cb17fb4306e75560b3dfb43631b6e"><td class="memItemLeft" align="right" valign="top"><a id="a7f1cb17fb4306e75560b3dfb43631b6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>discardWorkerDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a7f1cb17fb4306e75560b3dfb43631b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bac9fbd3149e15708d9e20ae2794ac0"><td class="memItemLeft" align="right" valign="top"><a id="a2bac9fbd3149e15708d9e20ae2794ac0"></a>
<a class="el" href="namespacefaster.html#aa8898687bc64536b60a3d5f365060cd6">fddType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTypeDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a2bac9fbd3149e15708d9e20ae2794ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa748066933101fc866f172ff023ba3ba"><td class="memItemLeft" align="right" valign="top"><a id="aa748066933101fc866f172ff023ba3ba"></a>
<a class="el" href="namespacefaster.html#aa8898687bc64536b60a3d5f365060cd6">fddType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getKeyTypeDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:aa748066933101fc866f172ff023ba3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8086a1616b67ba07b95a20982c07a7"><td class="memItemLeft" align="right" valign="top"><a id="a2d8086a1616b67ba07b95a20982c07a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDataDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *keys, void *data, size_t *lineSizes, size_t size)</td></tr>
<tr class="separator:a2d8086a1616b67ba07b95a20982c07a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857e013f9135c29d8cded8063c59b715"><td class="memItemLeft" align="right" valign="top"><a id="a857e013f9135c29d8cded8063c59b715"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDataRawDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *keys, void *data, size_t *lineSizes, size_t size)</td></tr>
<tr class="separator:a857e013f9135c29d8cded8063c59b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee614da230ed9bccf9559e3ae84848d3"><td class="memItemLeft" align="right" valign="top"><a id="aee614da230ed9bccf9559e3ae84848d3"></a>
size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>getLineSizesDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:aee614da230ed9bccf9559e3ae84848d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d1df07c836eb3f000b357e484c1e3"><td class="memItemLeft" align="right" valign="top"><a id="afc4d1df07c836eb3f000b357e484c1e3"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>getFddItemDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, size_t address)</td></tr>
<tr class="separator:afc4d1df07c836eb3f000b357e484c1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c5e5a7a3eb2b4416323fca23da067"><td class="memItemLeft" align="right" valign="top"><a id="ab75c5e5a7a3eb2b4416323fca23da067"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>getKeysDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:ab75c5e5a7a3eb2b4416323fca23da067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82c0576532f9e62986330843d32a546"><td class="memItemLeft" align="right" valign="top"><a id="ae82c0576532f9e62986330843d32a546"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>getDataDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:ae82c0576532f9e62986330843d32a546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa4c8c8e9a7b747dad9aa19793d396b"><td class="memItemLeft" align="right" valign="top"><a id="a0aa4c8c8e9a7b747dad9aa19793d396b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getSizeDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a0aa4c8c8e9a7b747dad9aa19793d396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a523ea6446d624b0b76dbe760dd83e"><td class="memItemLeft" align="right" valign="top"><a id="a16a523ea6446d624b0b76dbe760dd83e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>itemSizeDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a16a523ea6446d624b0b76dbe760dd83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60998a6d3a93ff4adda33a522febf560"><td class="memItemLeft" align="right" valign="top"><a id="a60998a6d3a93ff4adda33a522febf560"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>baseSizeDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a60998a6d3a93ff4adda33a522febf560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aed341cc30ca181ecc8f83d70f47e8"><td class="memItemLeft" align="right" valign="top"><a id="ad7aed341cc30ca181ecc8f83d70f47e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSizeDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, size_t s)</td></tr>
<tr class="separator:ad7aed341cc30ca181ecc8f83d70f47e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e36cf5ae4d3c2bb1c1af335ddfc984"><td class="memItemLeft" align="right" valign="top"><a id="a80e36cf5ae4d3c2bb1c1af335ddfc984"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deleteItemDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *item)</td></tr>
<tr class="separator:a80e36cf5ae4d3c2bb1c1af335ddfc984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4f7d456ac8d1a7ebf70af1f66d7d4"><td class="memItemLeft" align="right" valign="top"><a id="a55b4f7d456ac8d1a7ebf70af1f66d7d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrinkDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a55b4f7d456ac8d1a7ebf70af1f66d7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe54d99b55793c9903c60ac4ce07927a"><td class="memItemLeft" align="right" valign="top"><a id="abe54d99b55793c9903c60ac4ce07927a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *k, void *v, size_t s)</td></tr>
<tr class="separator:abe54d99b55793c9903c60ac4ce07927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab286e06918762237ceeb9fa963200aa6"><td class="memItemLeft" align="right" valign="top"><a id="ab286e06918762237ceeb9fa963200aa6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertListDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *v)</td></tr>
<tr class="separator:ab286e06918762237ceeb9fa963200aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c127b963912b8f80c4f1d4c470eaea2"><td class="memItemLeft" align="right" valign="top"><a id="a2c127b963912b8f80c4f1d4c470eaea2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>preapplyDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, unsigned long int id, void *func, <a class="el" href="namespacefaster.html#a64379512d12d41c6e58f176939abfd80">fddOpType</a> op, <a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *dest, <a class="el" href="classfaster_1_1fastComm.html">fastComm</a> *comm)</td></tr>
<tr class="separator:a2c127b963912b8f80c4f1d4c470eaea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ce2bb7a33c7d8b874041924dcdc21c"><td class="memItemLeft" align="right" valign="top"><a id="a32ce2bb7a33c7d8b874041924dcdc21c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>collectDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, <a class="el" href="classfaster_1_1fastComm.html">fastComm</a> *comm)</td></tr>
<tr class="separator:a32ce2bb7a33c7d8b874041924dcdc21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11af5925befea2c48241af140e4fd4"><td class="memItemLeft" align="right" valign="top"><a id="a8d11af5925befea2c48241af140e4fd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exchangeDataByKeyDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, <a class="el" href="classfaster_1_1fastComm.html">fastComm</a> *comm)</td></tr>
<tr class="separator:a8d11af5925befea2c48241af140e4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a15eb0405349caef37c186f114532b2"><td class="memItemLeft" align="right" valign="top"><a id="a6a15eb0405349caef37c186f114532b2"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>getKeyLocationsDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a6a15eb0405349caef37c186f114532b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd1f507a52359ed802be7dabc94aca6"><td class="memItemLeft" align="right" valign="top"><a id="a6bd1f507a52359ed802be7dabc94aca6"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>getUKeysDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a6bd1f507a52359ed802be7dabc94aca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3088346474ced3030086ce3f4a270f37"><td class="memItemLeft" align="right" valign="top"><a id="a3088346474ced3030086ce3f4a270f37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setUKeysDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *uk)</td></tr>
<tr class="separator:a3088346474ced3030086ce3f4a270f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8056268bb45a086bcd54f3350410fa"><td class="memItemLeft" align="right" valign="top"><a id="a1c8056268bb45a086bcd54f3350410fa"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>getKeyMapDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>)</td></tr>
<tr class="separator:a1c8056268bb45a086bcd54f3350410fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9be37a24e630446b8382dba98a0072"><td class="memItemLeft" align="right" valign="top"><a id="a8c9be37a24e630446b8382dba98a0072"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setKeyMapDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *km)</td></tr>
<tr class="separator:a8c9be37a24e630446b8382dba98a0072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421342b28d6fb61badbd4c7dcce19354"><td class="memItemLeft" align="right" valign="top"><a id="a421342b28d6fb61badbd4c7dcce19354"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeToFileDL</b> (<a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a> *<a class="el" href="classfaster_1_1fdd.html">fdd</a>, void *path, size_t procId, void *sufix)</td></tr>
<tr class="separator:a421342b28d6fb61badbd4c7dcce19354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8671c399def1682c578bc098410c53e6"><td class="memItemLeft" align="right" valign="top"><a id="a8671c399def1682c578bc098410c53e6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_INITIAL_SIZE</b> = 512*1024</td></tr>
<tr class="separator:a8671c399def1682c578bc098410c53e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1__workerFdd.html">_workerFdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1__workerFdd_3_01T_01_5_01_4.html">_workerFdd&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1__workerIFdd.html">_workerIFdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1__workerIFdd_3_01K_00_01T_01_5_01_4.html">_workerIFdd&lt; K, T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fastComm.html">fastComm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fastCommBuffer.html">fastCommBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fastContext.html">fastContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Framework context class.  <a href="classfaster_1_1fastContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fastScheduler.html">fastScheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fastSettings.html">fastSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context Configuration Class.  <a href="classfaster_1_1fastSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fastTask.html">fastTask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fdd.html">fdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Distributted Dataset(FDD) is like a cluster distributted Array. This class is the user side implementation.  <a href="classfaster_1_1fdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fdd_3_01T_01_5_01_4.html">fdd&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fddBase.html">fddBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fddCore.html">fddCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">core class that implements simple operations.  <a href="classfaster_1_1fddCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fddStorage.html">fddStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fddStorage_3_01T_01_5_01_4.html">fddStorage&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fddStorageBase.html">fddStorageBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1fddStorageCore.html">fddStorageCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1groupedFdd.html">groupedFdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1hasher.html">hasher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1hasher_3_01double_01_4.html">hasher&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1hasher_3_01float_01_4.html">hasher&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1hasher_3_01std_1_1string_01_4.html">hasher&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1hdfsEngine.html">hdfsEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1hdfsFile.html">hdfsFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1iFddCore.html">iFddCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1indexedFdd.html">indexedFdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1indexedFdd_3_01K_00_01T_01_5_01_4.html">indexedFdd&lt; K, T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1indexedFddStorage.html">indexedFddStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1indexedFddStorage_3_01K_00_01T_01_5_01_4.html">indexedFddStorage&lt; K, T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1indexedFddStorageCore.html">indexedFddStorageCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1procstat.html">procstat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1worker.html">worker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1workerFdd.html">workerFdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1workerFddBase.html">workerFddBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1workerFddCore.html">workerFddCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1workerFddGroup.html">workerFddGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1workerIFdd.html">workerIFdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaster_1_1workerIFddCore.html">workerIFddCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefaster.html">faster</a></li>
    <li class="footer">Generated on Tue Nov 22 2016 19:01:08 for libfaster API Documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
